# Loyalty Service

В репозитории находится реализация микро-сервиса, который отвечает за работу
системы лояльности и может использоваться в розничной торговле или сфере услуг,
везде, где за какую либо операцию (продажу) можно начислить определённое
количество баллов лояльности, а потом потратить эти баллы на оплату товаров/услуг.

Доступные операции:
- Начисление баллов лояльности за операцию (loyaltyPoints/deposit).
- Отмена начисления баллов за операцию (loyaltyPoints/cancel).
- Оплата покупки баллами лояльности (loyaltyPoints/withdraw).
- Получение текущего баланса по карте лояльности (накопленное количество баллов лояльности) (account/balance).

При начислении баллов лояльности необходимо указать правило начисления.

Правило начисления может быть:
- Относительным — количество начисляемых баллов лояльности рассчитывается как процент от суммы операции.
- Абсолютным — в независимости от суммы операции начисляется фиксированное количество баллов лояльности.

Задача:
1. Архив репозитория распаковать и опубликовать в публичный GIT-репозиторий.
2. В отдельной ветке необходимо провести рефакторинг LoyaltyPointsController в соответствии с Best Practices, Вашими предпочтениями и опытом.
3. Оформить Pull/Merge Request на ветку с исходным заданием и передать ссылку рекрутеру.
4. Допустимо использование любых средств, которые вы сочтете адекватными/необходимыми

Рекомендации:
1. Предоставить краткое описание выбранных архитектурных решений.
2. Детализировать историю изменений вместо одного итогового коммита.
3. Соблюдать общепринятые правила оформления кода, документации и истории изменений.
4. Не углубляться в детали реализации непринципиальных моментов.
5. Не тратить на задание больше 1 часа.

## Installation

- Windows
```bash
cd test-task-loyalty-service; docker-compose up
docker run -it --user www -v ${pwd}:/var/www test-task-loyalty-service /bin/sh -lc "composer install && cp .env.example .env && php artisan key:generate && php artisan migrate"
```

- Linux
```bash
cd test-task-loyalty-service && docker-compose up
docker run -it --user www -v $PWD:/var/www test-task-loyalty-service /bin/sh -lc "composer install && cp .env.example .env && php artisan key:generate && php artisan migrate"
```

## Пояснение по архитектурным решениям
1. Вся логика была вынесена в UseCase-сервис. Это позволяет переиспользовать ее в любой части приложения, а не только из конкретного контроллера.  
   По-хорошему, методы этого сервиса стоило бы вынести в отдельные Interactor-классы, но у меня не было на это времени. Это решение не позволит сервису превратится в god-объект, который потом будет сложно тестировать и паралельно дорабатывать.

2. Для всех кейсов, где есть привязка к инфраструктуре я использовал DI. Это позволит покрыть код unit-тестами.

3. Для доступа к слою данных был применен паттерн Репозиторий (настолько это позволяет Eloquent и временые ограничения на реализацию задачи). Это даст следующие:
   - Репоизиторий можно будет легко замокать, что даст возможность покрыть сервис unit-тестами;
   - Все запросы к БД будут находиться в одном месте, что в последующем даст возможность легко найти и переписать их в случае изменения системного дизайна (добавится репликация, добавятся промежуточные хранилища, потребуется мигрировать на другую СУБД).

4. Для успешной операции пополнения баланса была применена событийная модель. Это решене позволяет расширить поведение системы без именения источника(ов) события, резделить отвественность, а так же позволяет избавиться от дублирования кода в случаях, когда система должна одинаково реагировать на результат одной и той же операции в разных частях системы.  
   По-хорошему, такие события должны триггериться и в других UseCase-ах (отмена, списание), но я посчитал, что в данном случае это лишнее.

5. Отправка email-уведомления была вынесена в асинхронный обработчик очереди, так как ранее эта операция блокировала поток выполнения PHP.

6. Метод с логикой расчета бонусов и созданием транзакции я разделил. На мой взгляд, он включает в себя сразу две отсветсвенности:
   1) Получение бонусного правила, применение бонусов, сохранение.
   2) Вычисление бонусов.

   Первая отвественность должна находиться в UseCase, так как она не содержит в себя бизнес-правил и плюс завязана на инфраструктуру.  
   Вторая отвественность - это бизнес-правило в чистом виде, поэтому это должно находиться в домменом слое.

7. Я не стал явно выделять доменный слой, так как в приложении сейчас нет доменных сущностей (AR-модели - это не домен), поэтому просто сделал что-то вроде анемичного сервиса (`App\Services\LoyaltyPoints\CalculateService`), который по задумке должен содеражить в себе бизнес-правила калькуляции бонусов.